# Escape from Tikal

This is a coprocessor with python-cartesi app example. It exemplifies how to use, create and setup the application. Use this repo to kickstart your own coprocessor applications.

# Requisites

TODO

# Running on local devnet

The process of building a cartesi machine and firing up the co-processor
infrastructure is performed through a makefile. In order to fire up the
co-processor infrastructure you should use the command

```
make up
```

After that you should build the Cartesi Machine used by the co-processor
operator. In order to do that, use the command

```
make build
```

Next, it's time to make the solver aquire the Cartesi Machine image.
The process consists of uploading the Cartesi Machine image to a local
AWS S3 like instance and notifying the solver to download it.
This is performed with the command

```
make publish
```

As time process takes a while (and it's asynchronous) you should check
it's status with the command

```
make publish-status
```

And wait until it shows the DAG import was completed. Next it's time to
tell the Co-processor operator to download the image. To perform this,
use the command

```
make ensure-publish
```

Now the Co-processor is aware of your image and it's time to deploy the
contract that issues tasks and receives callbacks from it. Use the command

```
make deploy-contract
```

This step will output the contract address. Now let's interact with the
deployed Co-processor. You need to specify the contract address that was
just shown as well as the payload. Use the command

```
CONTRACT_ADDRESS=<ADDRESS>
PAYLOAD=<PAYLOAD>
make send CONTRACT_ADDRESS=$CONTRACT_ADDRESS PAYLOAD=$PAYLOAD
```

This will send an input to the Co-processor using cast. 
note that this app example receives an abi encoded string as payload. 
Example payload:

```
PAYLOAD=0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000018486f77206d7563682069732074776f20706c75732074776f0000000000000000
```

You can check the docker container log for the operator ()with `docker compose logs -f operator` to see the status of the input 
processing and once it's completed you can check the solver log for the
callback with the results. You can later recover the results from the
events generated by the smart contract using the command

```
(source .env && cast logs --rpc-url $RPC_URL --address $CONTRACT_ADDRESS)
```

# Running on testnet

Create a testnet environment file `.env.<testnet>` with (For Holesky you should use `TASK_ISSUER=0x95401dc811bb5740090279Ba06cfA8fcF6113778` and `SOLVER_URL=https://cartesi-coprocessor-solver-prod.fly.dev`)

```
PRIVATE_KEY=
RPC_URL=
SOLVER_URL=
TASK_ISSUER=
```

And you can run similar commands wiht `<testnet>` suffiex:

```
make deploy-contract-<testnet>
make publish-<testnet>
make publish-status-<testnet>
make ensure-publish-<testnet>
make deploy-contract-<testnet>
make send-<testnet>
```
